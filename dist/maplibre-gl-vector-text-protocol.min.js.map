{"version":3,"file":"maplibre-gl-vector-text-protocol.min.js","sources":["../node_modules/d3-dsv/build/d3-dsv.js","../node_modules/@mapbox/sexagesimal/index.js","../node_modules/csv2geojson/index.js","../node_modules/topojson-client/src/identity.js","../node_modules/topojson-client/src/feature.js","../node_modules/topojson-client/src/transform.js","../node_modules/topojson-client/src/reverse.js","../node_modules/@tmcw/togeojson/dist/togeojson.es.mjs"],"sourcesContent":["// https://d3js.org/d3-dsv/ Version 1.0.1. Copyright 2016 Mike Bostock.\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.d3 = global.d3 || {})));\n}(this, function (exports) { 'use strict';\n\n  function objectConverter(columns) {\n    return new Function(\"d\", \"return {\" + columns.map(function(name, i) {\n      return JSON.stringify(name) + \": d[\" + i + \"]\";\n    }).join(\",\") + \"}\");\n  }\n\n  function customConverter(columns, f) {\n    var object = objectConverter(columns);\n    return function(row, i) {\n      return f(object(row), i, columns);\n    };\n  }\n\n  // Compute unique columns in order of discovery.\n  function inferColumns(rows) {\n    var columnSet = Object.create(null),\n        columns = [];\n\n    rows.forEach(function(row) {\n      for (var column in row) {\n        if (!(column in columnSet)) {\n          columns.push(columnSet[column] = column);\n        }\n      }\n    });\n\n    return columns;\n  }\n\n  function dsv(delimiter) {\n    var reFormat = new RegExp(\"[\\\"\" + delimiter + \"\\n]\"),\n        delimiterCode = delimiter.charCodeAt(0);\n\n    function parse(text, f) {\n      var convert, columns, rows = parseRows(text, function(row, i) {\n        if (convert) return convert(row, i - 1);\n        columns = row, convert = f ? customConverter(row, f) : objectConverter(row);\n      });\n      rows.columns = columns;\n      return rows;\n    }\n\n    function parseRows(text, f) {\n      var EOL = {}, // sentinel value for end-of-line\n          EOF = {}, // sentinel value for end-of-file\n          rows = [], // output rows\n          N = text.length,\n          I = 0, // current character index\n          n = 0, // the current line number\n          t, // the current token\n          eol; // is the current token followed by EOL?\n\n      function token() {\n        if (I >= N) return EOF; // special case: end of file\n        if (eol) return eol = false, EOL; // special case: end of line\n\n        // special case: quotes\n        var j = I, c;\n        if (text.charCodeAt(j) === 34) {\n          var i = j;\n          while (i++ < N) {\n            if (text.charCodeAt(i) === 34) {\n              if (text.charCodeAt(i + 1) !== 34) break;\n              ++i;\n            }\n          }\n          I = i + 2;\n          c = text.charCodeAt(i + 1);\n          if (c === 13) {\n            eol = true;\n            if (text.charCodeAt(i + 2) === 10) ++I;\n          } else if (c === 10) {\n            eol = true;\n          }\n          return text.slice(j + 1, i).replace(/\"\"/g, \"\\\"\");\n        }\n\n        // common case: find next delimiter or newline\n        while (I < N) {\n          var k = 1;\n          c = text.charCodeAt(I++);\n          if (c === 10) eol = true; // \\n\n          else if (c === 13) { eol = true; if (text.charCodeAt(I) === 10) ++I, ++k; } // \\r|\\r\\n\n          else if (c !== delimiterCode) continue;\n          return text.slice(j, I - k);\n        }\n\n        // special case: last token before EOF\n        return text.slice(j);\n      }\n\n      while ((t = token()) !== EOF) {\n        var a = [];\n        while (t !== EOL && t !== EOF) {\n          a.push(t);\n          t = token();\n        }\n        if (f && (a = f(a, n++)) == null) continue;\n        rows.push(a);\n      }\n\n      return rows;\n    }\n\n    function format(rows, columns) {\n      if (columns == null) columns = inferColumns(rows);\n      return [columns.map(formatValue).join(delimiter)].concat(rows.map(function(row) {\n        return columns.map(function(column) {\n          return formatValue(row[column]);\n        }).join(delimiter);\n      })).join(\"\\n\");\n    }\n\n    function formatRows(rows) {\n      return rows.map(formatRow).join(\"\\n\");\n    }\n\n    function formatRow(row) {\n      return row.map(formatValue).join(delimiter);\n    }\n\n    function formatValue(text) {\n      return text == null ? \"\"\n          : reFormat.test(text += \"\") ? \"\\\"\" + text.replace(/\\\"/g, \"\\\"\\\"\") + \"\\\"\"\n          : text;\n    }\n\n    return {\n      parse: parse,\n      parseRows: parseRows,\n      format: format,\n      formatRows: formatRows\n    };\n  }\n\n  var csv = dsv(\",\");\n\n  var csvParse = csv.parse;\n  var csvParseRows = csv.parseRows;\n  var csvFormat = csv.format;\n  var csvFormatRows = csv.formatRows;\n\n  var tsv = dsv(\"\\t\");\n\n  var tsvParse = tsv.parse;\n  var tsvParseRows = tsv.parseRows;\n  var tsvFormat = tsv.format;\n  var tsvFormatRows = tsv.formatRows;\n\n  exports.dsvFormat = dsv;\n  exports.csvParse = csvParse;\n  exports.csvParseRows = csvParseRows;\n  exports.csvFormat = csvFormat;\n  exports.csvFormatRows = csvFormatRows;\n  exports.tsvParse = tsvParse;\n  exports.tsvParseRows = tsvParseRows;\n  exports.tsvFormat = tsvFormat;\n  exports.tsvFormatRows = tsvFormatRows;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));","module.exports = element;\nmodule.exports.pair = pair;\nmodule.exports.format = format;\nmodule.exports.formatPair = formatPair;\nmodule.exports.coordToDMS = coordToDMS;\n\n\nfunction element(input, dims) {\n  var result = search(input, dims);\n  return (result === null) ? null : result.val;\n}\n\n\nfunction formatPair(input) {\n  return format(input.lat, 'lat') + ' ' + format(input.lon, 'lon');\n}\n\n\n// Is 0 North or South?\nfunction format(input, dim) {\n  var dms = coordToDMS(input, dim);\n  return dms.whole + '° ' +\n    (dms.minutes ? dms.minutes + '\\' ' : '') +\n    (dms.seconds ? dms.seconds + '\" ' : '') + dms.dir;\n}\n\n\nfunction coordToDMS(input, dim) {\n  var dirs = { lat: ['N', 'S'], lon: ['E', 'W'] }[dim] || '';\n  var dir = dirs[input >= 0 ? 0 : 1];\n  var abs = Math.abs(input);\n  var whole = Math.floor(abs);\n  var fraction = abs - whole;\n  var fractionMinutes = fraction * 60;\n  var minutes = Math.floor(fractionMinutes);\n  var seconds = Math.floor((fractionMinutes - minutes) * 60);\n\n  return {\n    whole: whole,\n    minutes: minutes,\n    seconds: seconds,\n    dir: dir\n  };\n}\n\n\nfunction search(input, dims) {\n  if (!dims) dims = 'NSEW';\n  if (typeof input !== 'string') return null;\n\n  input = input.toUpperCase();\n  var regex = /^[\\s\\,]*([NSEW])?\\s*([\\-|\\—|\\―]?[0-9.]+)[°º˚]?\\s*(?:([0-9.]+)['’′‘]\\s*)?(?:([0-9.]+)(?:''|\"|”|″)\\s*)?([NSEW])?/;\n\n  var m = input.match(regex);\n  if (!m) return null;  // no match\n\n  var matched = m[0];\n\n  // extract dimension.. m[1] = leading, m[5] = trailing\n  var dim;\n  if (m[1] && m[5]) {                 // if matched both..\n    dim = m[1];                       // keep leading\n    matched = matched.slice(0, -1);   // remove trailing dimension from match\n  } else {\n    dim = m[1] || m[5];\n  }\n\n  // if unrecognized dimension\n  if (dim && dims.indexOf(dim) === -1) return null;\n\n  // extract DMS\n  var deg = m[2] ? parseFloat(m[2]) : 0;\n  var min = m[3] ? parseFloat(m[3]) / 60 : 0;\n  var sec = m[4] ? parseFloat(m[4]) / 3600 : 0;\n  var sign = (deg < 0) ? -1 : 1;\n  if (dim === 'S' || dim === 'W') sign *= -1;\n\n  return {\n    val: (Math.abs(deg) + min + sec) * sign,\n    dim: dim,\n    matched: matched,\n    remain: input.slice(matched.length)\n  };\n}\n\n\nfunction pair(input, dims) {\n  input = input.trim();\n  var one = search(input, dims);\n  if (!one) return null;\n\n  input = one.remain.trim();\n  var two = search(input, dims);\n  if (!two || two.remain) return null;\n\n  if (one.dim) {\n    return swapdim(one.val, two.val, one.dim);\n  } else {\n    return [one.val, two.val];\n  }\n}\n\n\nfunction swapdim(a, b, dim) {\n  if (dim === 'N' || dim === 'S') return [a, b];\n  if (dim === 'W' || dim === 'E') return [b, a];\n}\n","'use strict';\n\nvar dsv = require('d3-dsv'),\n    sexagesimal = require('@mapbox/sexagesimal');\n\nvar latRegex = /(Lat)(itude)?/gi,\n    lonRegex = /(L)(on|ng)(gitude)?/i;\n\nfunction guessHeader(row, regexp) {\n    var name, match, score;\n    for (var f in row) {\n        match = f.match(regexp);\n        if (match && (!name || match[0].length / f.length > score)) {\n            score = match[0].length / f.length;\n            name = f;\n        }\n    }\n    return name;\n}\n\nfunction guessLatHeader(row) { return guessHeader(row, latRegex); }\nfunction guessLonHeader(row) { return guessHeader(row, lonRegex); }\n\nfunction isLat(f) { return !!f.match(latRegex); }\nfunction isLon(f) { return !!f.match(lonRegex); }\n\nfunction keyCount(o) {\n    return (typeof o == 'object') ? Object.keys(o).length : 0;\n}\n\nfunction autoDelimiter(x) {\n    var delimiters = [',', ';', '\\t', '|'];\n    var results = [];\n\n    delimiters.forEach(function (delimiter) {\n        var res = dsv.dsvFormat(delimiter).parse(x);\n        if (res.length >= 1) {\n            var count = keyCount(res[0]);\n            for (var i = 0; i < res.length; i++) {\n                if (keyCount(res[i]) !== count) return;\n            }\n            results.push({\n                delimiter: delimiter,\n                arity: Object.keys(res[0]).length,\n            });\n        }\n    });\n\n    if (results.length) {\n        return results.sort(function (a, b) {\n            return b.arity - a.arity;\n        })[0].delimiter;\n    } else {\n        return null;\n    }\n}\n\n/**\n * Silly stopgap for dsv to d3-dsv upgrade\n *\n * @param {Array} x dsv output\n * @returns {Array} array without columns member\n */\nfunction deleteColumns(x) {\n    delete x.columns;\n    return x;\n}\n\nfunction auto(x) {\n    var delimiter = autoDelimiter(x);\n    if (!delimiter) return null;\n    return deleteColumns(dsv.dsvFormat(delimiter).parse(x));\n}\n\nfunction csv2geojson(x, options, callback) {\n\n    if (!callback) {\n        callback = options;\n        options = {};\n    }\n\n    options.delimiter = options.delimiter || ',';\n\n    var latfield = options.latfield || '',\n        lonfield = options.lonfield || '',\n        crs = options.crs || '';\n\n    var features = [],\n        featurecollection = {type: 'FeatureCollection', features: features};\n\n    if (crs !== '') {\n        featurecollection.crs = {type: 'name', properties: {name: crs}};\n    }\n\n    if (options.delimiter === 'auto' && typeof x == 'string') {\n        options.delimiter = autoDelimiter(x);\n        if (!options.delimiter) {\n            callback({\n                type: 'Error',\n                message: 'Could not autodetect delimiter'\n            });\n            return;\n        }\n    }\n\n    var numericFields = options.numericFields ? options.numericFields.split(',') : null;\n\n    var parsed = (typeof x == 'string') ?\n        dsv.dsvFormat(options.delimiter).parse(x, function (d) {\n            if (numericFields) {\n                for (var key in d) {\n                    if (numericFields.includes(key)) {\n                        d[key] = +d[key];\n                    }\n                }\n            }\n            return d;\n        }) : x;\n\n    if (!parsed.length) {\n        callback(null, featurecollection);\n        return;\n    }\n\n    var errors = [];\n    var i;\n\n\n    if (!latfield) latfield = guessLatHeader(parsed[0]);\n    if (!lonfield) lonfield = guessLonHeader(parsed[0]);\n    var noGeometry = (!latfield || !lonfield);\n\n    if (noGeometry) {\n        for (i = 0; i < parsed.length; i++) {\n            features.push({\n                type: 'Feature',\n                properties: parsed[i],\n                geometry: null\n            });\n        }\n        callback(errors.length ? errors : null, featurecollection);\n        return;\n    }\n\n    for (i = 0; i < parsed.length; i++) {\n        if (parsed[i][lonfield] !== undefined &&\n            parsed[i][latfield] !== undefined) {\n\n            var lonk = parsed[i][lonfield],\n                latk = parsed[i][latfield],\n                lonf, latf,\n                a;\n\n            a = sexagesimal(lonk, 'EW');\n            if (a) lonk = a;\n            a = sexagesimal(latk, 'NS');\n            if (a) latk = a;\n\n            lonf = parseFloat(lonk);\n            latf = parseFloat(latk);\n\n            if (isNaN(lonf) ||\n                isNaN(latf)) {\n                errors.push({\n                    message: 'A row contained an invalid value for latitude or longitude',\n                    row: parsed[i],\n                    index: i\n                });\n            } else {\n                if (!options.includeLatLon) {\n                    delete parsed[i][lonfield];\n                    delete parsed[i][latfield];\n                }\n\n                features.push({\n                    type: 'Feature',\n                    properties: parsed[i],\n                    geometry: {\n                        type: 'Point',\n                        coordinates: [\n                            parseFloat(lonf),\n                            parseFloat(latf)\n                        ]\n                    }\n                });\n            }\n        }\n    }\n\n    callback(errors.length ? errors : null, featurecollection);\n}\n\nfunction toLine(gj) {\n    var features = gj.features;\n    var line = {\n        type: 'Feature',\n        geometry: {\n            type: 'LineString',\n            coordinates: []\n        }\n    };\n    for (var i = 0; i < features.length; i++) {\n        line.geometry.coordinates.push(features[i].geometry.coordinates);\n    }\n    line.properties = features.reduce(function (aggregatedProperties, newFeature) {\n        for (var key in newFeature.properties) {\n            if (!aggregatedProperties[key]) {\n                aggregatedProperties[key] = [];\n            }\n            aggregatedProperties[key].push(newFeature.properties[key]);\n        }\n        return aggregatedProperties;\n    }, {});\n    return {\n        type: 'FeatureCollection',\n        features: [line]\n    };\n}\n\nfunction toPolygon(gj) {\n    var features = gj.features;\n    var poly = {\n        type: 'Feature',\n        geometry: {\n            type: 'Polygon',\n            coordinates: [[]]\n        }\n    };\n    for (var i = 0; i < features.length; i++) {\n        poly.geometry.coordinates[0].push(features[i].geometry.coordinates);\n    }\n    poly.properties = features.reduce(function (aggregatedProperties, newFeature) {\n        for (var key in newFeature.properties) {\n            if (!aggregatedProperties[key]) {\n                aggregatedProperties[key] = [];\n            }\n            aggregatedProperties[key].push(newFeature.properties[key]);\n        }\n        return aggregatedProperties;\n    }, {});\n    return {\n        type: 'FeatureCollection',\n        features: [poly]\n    };\n}\n\nmodule.exports = {\n    isLon: isLon,\n    isLat: isLat,\n    guessLatHeader: guessLatHeader,\n    guessLonHeader: guessLonHeader,\n    csv: dsv.csvParse,\n    tsv: dsv.tsvParse,\n    dsv: dsv,\n    auto: auto,\n    csv2geojson: csv2geojson,\n    toLine: toLine,\n    toPolygon: toPolygon\n};\n","export default function(x) {\n  return x;\n}\n","import reverse from \"./reverse.js\";\nimport transform from \"./transform.js\";\n\nexport default function(topology, o) {\n  if (typeof o === \"string\") o = topology.objects[o];\n  return o.type === \"GeometryCollection\"\n      ? {type: \"FeatureCollection\", features: o.geometries.map(function(o) { return feature(topology, o); })}\n      : feature(topology, o);\n}\n\nfunction feature(topology, o) {\n  var id = o.id,\n      bbox = o.bbox,\n      properties = o.properties == null ? {} : o.properties,\n      geometry = object(topology, o);\n  return id == null && bbox == null ? {type: \"Feature\", properties: properties, geometry: geometry}\n      : bbox == null ? {type: \"Feature\", id: id, properties: properties, geometry: geometry}\n      : {type: \"Feature\", id: id, bbox: bbox, properties: properties, geometry: geometry};\n}\n\nexport function object(topology, o) {\n  var transformPoint = transform(topology.transform),\n      arcs = topology.arcs;\n\n  function arc(i, points) {\n    if (points.length) points.pop();\n    for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {\n      points.push(transformPoint(a[k], k));\n    }\n    if (i < 0) reverse(points, n);\n  }\n\n  function point(p) {\n    return transformPoint(p);\n  }\n\n  function line(arcs) {\n    var points = [];\n    for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);\n    if (points.length < 2) points.push(points[0]); // This should never happen per the specification.\n    return points;\n  }\n\n  function ring(arcs) {\n    var points = line(arcs);\n    while (points.length < 4) points.push(points[0]); // This may happen if an arc has only two points.\n    return points;\n  }\n\n  function polygon(arcs) {\n    return arcs.map(ring);\n  }\n\n  function geometry(o) {\n    var type = o.type, coordinates;\n    switch (type) {\n      case \"GeometryCollection\": return {type: type, geometries: o.geometries.map(geometry)};\n      case \"Point\": coordinates = point(o.coordinates); break;\n      case \"MultiPoint\": coordinates = o.coordinates.map(point); break;\n      case \"LineString\": coordinates = line(o.arcs); break;\n      case \"MultiLineString\": coordinates = o.arcs.map(line); break;\n      case \"Polygon\": coordinates = polygon(o.arcs); break;\n      case \"MultiPolygon\": coordinates = o.arcs.map(polygon); break;\n      default: return null;\n    }\n    return {type: type, coordinates: coordinates};\n  }\n\n  return geometry(o);\n}\n","import identity from \"./identity.js\";\n\nexport default function(transform) {\n  if (transform == null) return identity;\n  var x0,\n      y0,\n      kx = transform.scale[0],\n      ky = transform.scale[1],\n      dx = transform.translate[0],\n      dy = transform.translate[1];\n  return function(input, i) {\n    if (!i) x0 = y0 = 0;\n    var j = 2, n = input.length, output = new Array(n);\n    output[0] = (x0 += input[0]) * kx + dx;\n    output[1] = (y0 += input[1]) * ky + dy;\n    while (j < n) output[j] = input[j], ++j;\n    return output;\n  };\n}\n","export default function(array, n) {\n  var t, j = array.length, i = j - n;\n  while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;\n}\n","function $(element, tagName) {\n    return Array.from(element.getElementsByTagName(tagName));\n}\nfunction normalizeId(id) {\n    return id[0] === \"#\" ? id : `#${id}`;\n}\nfunction $ns(element, tagName, ns) {\n    return Array.from(element.getElementsByTagNameNS(ns, tagName));\n}\n/**\n * get the content of a text node, if any\n */\nfunction nodeVal(node) {\n    node?.normalize();\n    return (node && node.textContent) || \"\";\n}\n/**\n * Get one Y child of X, if any, otherwise null\n */\nfunction get1(node, tagName, callback) {\n    const n = node.getElementsByTagName(tagName);\n    const result = n.length ? n[0] : null;\n    if (result && callback)\n        callback(result);\n    return result;\n}\nfunction get(node, tagName, callback) {\n    const properties = {};\n    if (!node)\n        return properties;\n    const n = node.getElementsByTagName(tagName);\n    const result = n.length ? n[0] : null;\n    if (result && callback) {\n        return callback(result, properties);\n    }\n    return properties;\n}\nfunction val1(node, tagName, callback) {\n    const val = nodeVal(get1(node, tagName));\n    if (val && callback)\n        return callback(val) || {};\n    return {};\n}\nfunction $num(node, tagName, callback) {\n    const val = parseFloat(nodeVal(get1(node, tagName)));\n    if (isNaN(val))\n        return undefined;\n    if (val && callback)\n        return callback(val) || {};\n    return {};\n}\nfunction num1(node, tagName, callback) {\n    const val = parseFloat(nodeVal(get1(node, tagName)));\n    if (isNaN(val))\n        return undefined;\n    if (val && callback)\n        callback(val);\n    return val;\n}\nfunction getMulti(node, propertyNames) {\n    const properties = {};\n    for (const property of propertyNames) {\n        val1(node, property, (val) => {\n            properties[property] = val;\n        });\n    }\n    return properties;\n}\nfunction isElement(node) {\n    return node?.nodeType === 1;\n}\n\nfunction getLineStyle(node) {\n    return get(node, \"line\", (lineStyle) => {\n        const val = Object.assign({}, val1(lineStyle, \"color\", (color) => {\n            return { stroke: `#${color}` };\n        }), $num(lineStyle, \"opacity\", (opacity) => {\n            return { \"stroke-opacity\": opacity };\n        }), $num(lineStyle, \"width\", (width) => {\n            // GPX width is in mm, convert to px with 96 px per inch\n            return { \"stroke-width\": (width * 96) / 25.4 };\n        }));\n        return val;\n    });\n}\n\nfunction getExtensions(node) {\n    let values = [];\n    if (node === null)\n        return values;\n    for (const child of Array.from(node.childNodes)) {\n        if (!isElement(child))\n            continue;\n        const name = abbreviateName(child.nodeName);\n        if (name === \"gpxtpx:TrackPointExtension\") {\n            // loop again for nested garmin extensions (eg. \"gpxtpx:hr\")\n            values = values.concat(getExtensions(child));\n        }\n        else {\n            // push custom extension (eg. \"power\")\n            const val = nodeVal(child);\n            values.push([name, parseNumeric(val)]);\n        }\n    }\n    return values;\n}\nfunction abbreviateName(name) {\n    return [\"heart\", \"gpxtpx:hr\", \"hr\"].includes(name) ? \"heart\" : name;\n}\nfunction parseNumeric(val) {\n    const num = parseFloat(val);\n    return isNaN(num) ? val : num;\n}\n\nfunction coordPair$1(node) {\n    const ll = [\n        parseFloat(node.getAttribute(\"lon\") || \"\"),\n        parseFloat(node.getAttribute(\"lat\") || \"\"),\n    ];\n    if (isNaN(ll[0]) || isNaN(ll[1])) {\n        return null;\n    }\n    num1(node, \"ele\", (val) => {\n        ll.push(val);\n    });\n    const time = get1(node, \"time\");\n    return {\n        coordinates: ll,\n        time: time ? nodeVal(time) : null,\n        extendedValues: getExtensions(get1(node, \"extensions\")),\n    };\n}\n\nfunction extractProperties(node) {\n    const properties = getMulti(node, [\n        \"name\",\n        \"cmt\",\n        \"desc\",\n        \"type\",\n        \"time\",\n        \"keywords\",\n    ]);\n    const extensions = Array.from(node.getElementsByTagNameNS(\"http://www.garmin.com/xmlschemas/GpxExtensions/v3\", \"*\"));\n    for (const child of extensions) {\n        if (child.parentNode?.parentNode === node) {\n            properties[child.tagName.replace(\":\", \"_\")] = nodeVal(child);\n        }\n    }\n    const links = $(node, \"link\");\n    if (links.length) {\n        properties.links = links.map((link) => Object.assign({ href: link.getAttribute(\"href\") }, getMulti(link, [\"text\", \"type\"])));\n    }\n    return properties;\n}\n\n/**\n * Extract points from a trkseg or rte element.\n */\nfunction getPoints$1(node, pointname) {\n    const pts = $(node, pointname);\n    const line = [];\n    const times = [];\n    const extendedValues = {};\n    for (let i = 0; i < pts.length; i++) {\n        const c = coordPair$1(pts[i]);\n        if (!c) {\n            continue;\n        }\n        line.push(c.coordinates);\n        if (c.time)\n            times.push(c.time);\n        for (const [name, val] of c.extendedValues) {\n            const plural = name === \"heart\" ? name : name.replace(\"gpxtpx:\", \"\") + \"s\";\n            if (!extendedValues[plural]) {\n                extendedValues[plural] = Array(pts.length).fill(null);\n            }\n            extendedValues[plural][i] = val;\n        }\n    }\n    if (line.length < 2)\n        return; // Invalid line in GeoJSON\n    return {\n        line: line,\n        times: times,\n        extendedValues: extendedValues,\n    };\n}\n/**\n * Extract a LineString geometry from a rte\n * element.\n */\nfunction getRoute(node) {\n    const line = getPoints$1(node, \"rtept\");\n    if (!line)\n        return;\n    return {\n        type: \"Feature\",\n        properties: Object.assign({ _gpxType: \"rte\" }, extractProperties(node), getLineStyle(get1(node, \"extensions\"))),\n        geometry: {\n            type: \"LineString\",\n            coordinates: line.line,\n        },\n    };\n}\nfunction getTrack(node) {\n    const segments = $(node, \"trkseg\");\n    const track = [];\n    const times = [];\n    const extractedLines = [];\n    for (const segment of segments) {\n        const line = getPoints$1(segment, \"trkpt\");\n        if (line) {\n            extractedLines.push(line);\n            if (line.times && line.times.length)\n                times.push(line.times);\n        }\n    }\n    if (extractedLines.length === 0)\n        return null;\n    const multi = extractedLines.length > 1;\n    const properties = Object.assign({ _gpxType: \"trk\" }, extractProperties(node), getLineStyle(get1(node, \"extensions\")), times.length\n        ? {\n            coordinateProperties: {\n                times: multi ? times : times[0],\n            },\n        }\n        : {});\n    for (const line of extractedLines) {\n        track.push(line.line);\n        if (!properties.coordinateProperties) {\n            properties.coordinateProperties = {};\n        }\n        const props = properties.coordinateProperties;\n        const entries = Object.entries(line.extendedValues);\n        for (let i = 0; i < entries.length; i++) {\n            const [name, val] = entries[i];\n            if (multi) {\n                if (!props[name]) {\n                    props[name] = extractedLines.map((line) => new Array(line.line.length).fill(null));\n                }\n                props[name][i] = val;\n            }\n            else {\n                props[name] = val;\n            }\n        }\n    }\n    return {\n        type: \"Feature\",\n        properties: properties,\n        geometry: multi\n            ? {\n                type: \"MultiLineString\",\n                coordinates: track,\n            }\n            : {\n                type: \"LineString\",\n                coordinates: track[0],\n            },\n    };\n}\n/**\n * Extract a point, if possible, from a given node,\n * which is usually a wpt or trkpt\n */\nfunction getPoint(node) {\n    const properties = Object.assign(extractProperties(node), getMulti(node, [\"sym\"]));\n    const pair = coordPair$1(node);\n    if (!pair)\n        return null;\n    return {\n        type: \"Feature\",\n        properties,\n        geometry: {\n            type: \"Point\",\n            coordinates: pair.coordinates,\n        },\n    };\n}\n/**\n * Convert GPX to GeoJSON incrementally, returning\n * a [Generator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators)\n * that yields output feature by feature.\n */\nfunction* gpxGen(node) {\n    for (const track of $(node, \"trk\")) {\n        const feature = getTrack(track);\n        if (feature)\n            yield feature;\n    }\n    for (const route of $(node, \"rte\")) {\n        const feature = getRoute(route);\n        if (feature)\n            yield feature;\n    }\n    for (const waypoint of $(node, \"wpt\")) {\n        const point = getPoint(waypoint);\n        if (point)\n            yield point;\n    }\n}\n/**\n *\n * Convert a GPX document to GeoJSON. The first argument, `doc`, must be a GPX\n * document as an XML DOM - not as a string. You can get this using jQuery's default\n * `.ajax` function or using a bare XMLHttpRequest with the `.response` property\n * holding an XML DOM.\n *\n * The output is a JavaScript object of GeoJSON data, same as `.kml` outputs, with the\n * addition of a `_gpxType` property on each `LineString` feature that indicates whether\n * the feature was encoded as a route (`rte`) or track (`trk`) in the GPX document.\n */\nfunction gpx(node) {\n    return {\n        type: \"FeatureCollection\",\n        features: Array.from(gpxGen(node)),\n    };\n}\n\nconst EXTENSIONS_NS = \"http://www.garmin.com/xmlschemas/ActivityExtension/v2\";\nconst TRACKPOINT_ATTRIBUTES = [\n    [\"heartRate\", \"heartRates\"],\n    [\"Cadence\", \"cadences\"],\n    // Extended Trackpoint attributes\n    [\"Speed\", \"speeds\"],\n    [\"Watts\", \"watts\"],\n];\nconst LAP_ATTRIBUTES = [\n    [\"TotalTimeSeconds\", \"totalTimeSeconds\"],\n    [\"DistanceMeters\", \"distanceMeters\"],\n    [\"MaximumSpeed\", \"maxSpeed\"],\n    [\"AverageHeartRateBpm\", \"avgHeartRate\"],\n    [\"MaximumHeartRateBpm\", \"maxHeartRate\"],\n    // Extended Lap attributes\n    [\"AvgSpeed\", \"avgSpeed\"],\n    [\"AvgWatts\", \"avgWatts\"],\n    [\"MaxWatts\", \"maxWatts\"],\n];\nfunction getProperties(node, attributeNames) {\n    const properties = [];\n    for (const [tag, alias] of attributeNames) {\n        let elem = get1(node, tag);\n        if (!elem) {\n            const elements = node.getElementsByTagNameNS(EXTENSIONS_NS, tag);\n            if (elements.length) {\n                elem = elements[0];\n            }\n        }\n        const val = parseFloat(nodeVal(elem));\n        if (!isNaN(val)) {\n            properties.push([alias, val]);\n        }\n    }\n    return properties;\n}\nfunction coordPair(node) {\n    const ll = [num1(node, \"LongitudeDegrees\"), num1(node, \"LatitudeDegrees\")];\n    if (ll[0] === undefined ||\n        isNaN(ll[0]) ||\n        ll[1] === undefined ||\n        isNaN(ll[1])) {\n        return null;\n    }\n    const heartRate = get1(node, \"HeartRateBpm\");\n    const time = nodeVal(get1(node, \"Time\"));\n    get1(node, \"AltitudeMeters\", (alt) => {\n        const a = parseFloat(nodeVal(alt));\n        if (!isNaN(a)) {\n            ll.push(a);\n        }\n    });\n    return {\n        coordinates: ll,\n        time: time || null,\n        heartRate: heartRate ? parseFloat(nodeVal(heartRate)) : null,\n        extensions: getProperties(node, TRACKPOINT_ATTRIBUTES),\n    };\n}\nfunction getPoints(node) {\n    const pts = $(node, \"Trackpoint\");\n    const line = [];\n    const times = [];\n    const heartRates = [];\n    if (pts.length < 2)\n        return null; // Invalid line in GeoJSON\n    const extendedProperties = {};\n    const result = { extendedProperties };\n    for (let i = 0; i < pts.length; i++) {\n        const c = coordPair(pts[i]);\n        if (c === null)\n            continue;\n        line.push(c.coordinates);\n        const { time, heartRate, extensions } = c;\n        if (time)\n            times.push(time);\n        if (heartRate)\n            heartRates.push(heartRate);\n        for (const [alias, value] of extensions) {\n            if (!extendedProperties[alias]) {\n                extendedProperties[alias] = Array(pts.length).fill(null);\n            }\n            extendedProperties[alias][i] = value;\n        }\n    }\n    if (line.length < 2)\n        return null;\n    return Object.assign(result, {\n        line: line,\n        times: times,\n        heartRates: heartRates,\n    });\n}\nfunction getLap(node) {\n    const segments = $(node, \"Track\");\n    const track = [];\n    const times = [];\n    const heartRates = [];\n    const allExtendedProperties = [];\n    let line;\n    const properties = Object.assign(Object.fromEntries(getProperties(node, LAP_ATTRIBUTES)), get(node, \"Name\", (nameElement) => {\n        return { name: nodeVal(nameElement) };\n    }));\n    for (const segment of segments) {\n        line = getPoints(segment);\n        if (line) {\n            track.push(line.line);\n            if (line.times.length)\n                times.push(line.times);\n            if (line.heartRates.length)\n                heartRates.push(line.heartRates);\n            allExtendedProperties.push(line.extendedProperties);\n        }\n    }\n    for (let i = 0; i < allExtendedProperties.length; i++) {\n        const extendedProperties = allExtendedProperties[i];\n        for (const property in extendedProperties) {\n            if (segments.length === 1) {\n                if (line) {\n                    properties[property] = line.extendedProperties[property];\n                }\n            }\n            else {\n                if (!properties[property]) {\n                    properties[property] = track.map((track) => Array(track.length).fill(null));\n                }\n                properties[property][i] = extendedProperties[property];\n            }\n        }\n    }\n    if (track.length === 0)\n        return null;\n    if (times.length || heartRates.length) {\n        properties.coordinateProperties = Object.assign(times.length\n            ? {\n                times: track.length === 1 ? times[0] : times,\n            }\n            : {}, heartRates.length\n            ? {\n                heart: track.length === 1 ? heartRates[0] : heartRates,\n            }\n            : {});\n    }\n    return {\n        type: \"Feature\",\n        properties: properties,\n        geometry: track.length === 1\n            ? {\n                type: \"LineString\",\n                coordinates: track[0],\n            }\n            : {\n                type: \"MultiLineString\",\n                coordinates: track,\n            },\n    };\n}\n/**\n * Incrementally convert a TCX document to GeoJSON. The\n * first argument, `doc`, must be a TCX\n * document as an XML DOM - not as a string.\n */\nfunction* tcxGen(node) {\n    for (const lap of $(node, \"Lap\")) {\n        const feature = getLap(lap);\n        if (feature)\n            yield feature;\n    }\n    for (const course of $(node, \"Courses\")) {\n        const feature = getLap(course);\n        if (feature)\n            yield feature;\n    }\n}\n/**\n * Convert a TCX document to GeoJSON. The first argument, `doc`, must be a TCX\n * document as an XML DOM - not as a string.\n */\nfunction tcx(node) {\n    return {\n        type: \"FeatureCollection\",\n        features: Array.from(tcxGen(node)),\n    };\n}\n\nfunction fixColor(v, prefix) {\n    const properties = {};\n    const colorProp = prefix == \"stroke\" || prefix === \"fill\" ? prefix : prefix + \"-color\";\n    if (v[0] === \"#\") {\n        v = v.substring(1);\n    }\n    if (v.length === 6 || v.length === 3) {\n        properties[colorProp] = \"#\" + v;\n    }\n    else if (v.length === 8) {\n        properties[prefix + \"-opacity\"] = parseInt(v.substring(0, 2), 16) / 255;\n        properties[colorProp] =\n            \"#\" + v.substring(6, 8) + v.substring(4, 6) + v.substring(2, 4);\n    }\n    return properties;\n}\n\nfunction numericProperty(node, source, target) {\n    const properties = {};\n    num1(node, source, (val) => {\n        properties[target] = val;\n    });\n    return properties;\n}\nfunction getColor(node, output) {\n    return get(node, \"color\", (elem) => fixColor(nodeVal(elem), output));\n}\nfunction extractIcon(node) {\n    return get(node, \"IconStyle\", (iconStyle) => {\n        return Object.assign(getColor(iconStyle, \"icon\"), numericProperty(iconStyle, \"scale\", \"icon-scale\"), numericProperty(iconStyle, \"heading\", \"icon-heading\"), get(iconStyle, \"hotSpot\", (hotspot) => {\n            const left = parseFloat(hotspot.getAttribute(\"x\") || \"\");\n            const top = parseFloat(hotspot.getAttribute(\"y\") || \"\");\n            const xunits = hotspot.getAttribute(\"xunits\") || \"\";\n            const yunits = hotspot.getAttribute(\"yunits\") || \"\";\n            if (!isNaN(left) && !isNaN(top))\n                return {\n                    \"icon-offset\": [left, top],\n                    \"icon-offset-units\": [xunits, yunits],\n                };\n            return {};\n        }), get(iconStyle, \"Icon\", (icon, properties) => {\n            val1(icon, \"href\", (href) => {\n                properties.icon = href;\n            });\n            return properties;\n        }));\n    });\n}\nfunction extractLabel(node) {\n    return get(node, \"LabelStyle\", (labelStyle) => {\n        return Object.assign(getColor(labelStyle, \"label\"), numericProperty(labelStyle, \"scale\", \"label-scale\"));\n    });\n}\nfunction extractLine(node) {\n    return get(node, \"LineStyle\", (lineStyle) => {\n        return Object.assign(getColor(lineStyle, \"stroke\"), numericProperty(lineStyle, \"width\", \"stroke-width\"));\n    });\n}\nfunction extractPoly(node) {\n    return get(node, \"PolyStyle\", (polyStyle, properties) => {\n        return Object.assign(properties, get(polyStyle, \"color\", (elem) => fixColor(nodeVal(elem), \"fill\")), val1(polyStyle, \"fill\", (fill) => {\n            if (fill === \"0\")\n                return { \"fill-opacity\": 0 };\n        }), val1(polyStyle, \"outline\", (outline) => {\n            if (outline === \"0\")\n                return { \"stroke-opacity\": 0 };\n        }));\n    });\n}\nfunction extractStyle(node) {\n    return Object.assign({}, extractPoly(node), extractLine(node), extractLabel(node), extractIcon(node));\n}\n\nconst removeSpace = /\\s*/g;\nconst trimSpace = /^\\s*|\\s*$/g;\nconst splitSpace = /\\s+/;\n/**\n * Get one coordinate from a coordinate array, if any\n */\nfunction coord1(value) {\n    return value\n        .replace(removeSpace, \"\")\n        .split(\",\")\n        .map(parseFloat)\n        .filter((num) => !isNaN(num))\n        .slice(0, 3);\n}\n/**\n * Get all coordinates from a coordinate array as [[],[]]\n */\nfunction coord(value) {\n    return value\n        .replace(trimSpace, \"\")\n        .split(splitSpace)\n        .map(coord1)\n        .filter((coord) => {\n        return coord.length >= 2;\n    });\n}\nfunction gxCoords(node) {\n    let elems = $(node, \"coord\");\n    if (elems.length === 0) {\n        elems = $ns(node, \"coord\", \"*\");\n    }\n    const coordinates = elems.map((elem) => {\n        return nodeVal(elem).split(\" \").map(parseFloat);\n    });\n    if (coordinates.length === 0) {\n        return null;\n    }\n    return {\n        geometry: coordinates.length > 2\n            ? {\n                type: \"LineString\",\n                coordinates,\n            }\n            : {\n                type: \"Point\",\n                coordinates: coordinates[0],\n            },\n        times: $(node, \"when\").map((elem) => nodeVal(elem)),\n    };\n}\nfunction fixRing(ring) {\n    if (ring.length === 0)\n        return ring;\n    const first = ring[0];\n    const last = ring[ring.length - 1];\n    let equal = true;\n    for (let i = 0; i < Math.max(first.length, last.length); i++) {\n        if (first[i] !== last[i]) {\n            equal = false;\n            break;\n        }\n    }\n    if (!equal) {\n        return ring.concat([ring[0]]);\n    }\n    return ring;\n}\nconst GEO_TYPES = [\n    \"Polygon\",\n    \"LineString\",\n    \"Point\",\n    \"Track\",\n    \"gx:Track\",\n];\nfunction getCoordinates(node) {\n    return nodeVal(get1(node, \"coordinates\"));\n}\nfunction getGeometry(node) {\n    const geometries = [];\n    const coordTimes = [];\n    for (const t of [\"MultiGeometry\", \"MultiTrack\", \"gx:MultiTrack\"]) {\n        const elem = get1(node, t);\n        if (elem) {\n            return getGeometry(elem);\n        }\n    }\n    for (const geoType of GEO_TYPES) {\n        for (const geomNode of $(node, geoType)) {\n            switch (geoType) {\n                case \"Point\": {\n                    const coordinates = coord1(getCoordinates(geomNode));\n                    if (coordinates.length >= 2) {\n                        geometries.push({\n                            type: \"Point\",\n                            coordinates,\n                        });\n                    }\n                    break;\n                }\n                case \"LineString\": {\n                    const coordinates = coord(getCoordinates(geomNode));\n                    if (coordinates.length >= 2) {\n                        geometries.push({\n                            type: \"LineString\",\n                            coordinates,\n                        });\n                    }\n                    break;\n                }\n                case \"Polygon\": {\n                    const coords = [];\n                    for (const linearRing of $(geomNode, \"LinearRing\")) {\n                        const ring = fixRing(coord(getCoordinates(linearRing)));\n                        if (ring.length >= 4) {\n                            coords.push(ring);\n                        }\n                    }\n                    if (coords.length) {\n                        geometries.push({\n                            type: \"Polygon\",\n                            coordinates: coords,\n                        });\n                    }\n                    break;\n                }\n                case \"Track\":\n                case \"gx:Track\": {\n                    const gx = gxCoords(geomNode);\n                    if (!gx)\n                        break;\n                    const { times, geometry } = gx;\n                    geometries.push(geometry);\n                    if (times.length)\n                        coordTimes.push(times);\n                    break;\n                }\n            }\n        }\n    }\n    return {\n        geometries,\n        coordTimes,\n    };\n}\n\nfunction extractExtendedData(node) {\n    return get(node, \"ExtendedData\", (extendedData, properties) => {\n        for (const data of $(extendedData, \"Data\")) {\n            properties[data.getAttribute(\"name\") || \"\"] = nodeVal(get1(data, \"value\"));\n        }\n        for (const simpleData of $(extendedData, \"SimpleData\")) {\n            properties[simpleData.getAttribute(\"name\") || \"\"] = nodeVal(simpleData);\n        }\n        return properties;\n    });\n}\nfunction geometryListToGeometry(geometries) {\n    return geometries.length === 0\n        ? null\n        : geometries.length === 1\n            ? geometries[0]\n            : {\n                type: \"GeometryCollection\",\n                geometries,\n            };\n}\nfunction extractTimeSpan(node) {\n    return get(node, \"TimeSpan\", (timeSpan) => {\n        return {\n            timespan: {\n                begin: nodeVal(get1(timeSpan, \"begin\")),\n                end: nodeVal(get1(timeSpan, \"end\")),\n            },\n        };\n    });\n}\nfunction extractTimeStamp(node) {\n    return get(node, \"TimeStamp\", (timeStamp) => {\n        return { timestamp: nodeVal(get1(timeStamp, \"when\")) };\n    });\n}\nfunction extractCascadedStyle(node, styleMap) {\n    return val1(node, \"styleUrl\", (styleUrl) => {\n        styleUrl = normalizeId(styleUrl);\n        if (styleMap[styleUrl]) {\n            return Object.assign({ styleUrl }, styleMap[styleUrl]);\n        }\n        // For backward-compatibility. Should we still include\n        // styleUrl even if it's not resolved?\n        return { styleUrl };\n    });\n}\nfunction getMaybeHTMLDescription(node) {\n    const descriptionNode = get1(node, \"description\");\n    for (const c of Array.from(descriptionNode?.childNodes || [])) {\n        if (c.nodeType === 4) {\n            return {\n                description: {\n                    \"@type\": \"html\",\n                    value: nodeVal(c),\n                },\n            };\n        }\n    }\n    return {};\n}\nfunction getPlacemark(node, styleMap) {\n    const { coordTimes, geometries } = getGeometry(node);\n    const feature = {\n        type: \"Feature\",\n        geometry: geometryListToGeometry(geometries),\n        properties: Object.assign(getMulti(node, [\n            \"name\",\n            \"address\",\n            \"visibility\",\n            \"open\",\n            \"phoneNumber\",\n            \"description\",\n        ]), getMaybeHTMLDescription(node), extractCascadedStyle(node, styleMap), extractStyle(node), extractExtendedData(node), extractTimeSpan(node), extractTimeStamp(node), coordTimes.length\n            ? {\n                coordinateProperties: {\n                    times: coordTimes.length === 1 ? coordTimes[0] : coordTimes,\n                },\n            }\n            : {}),\n    };\n    const id = node.getAttribute(\"id\");\n    if (id !== null && id !== \"\")\n        feature.id = id;\n    return feature;\n}\n\nfunction getStyleId(style) {\n    let id = style.getAttribute(\"id\");\n    const parentNode = style.parentNode;\n    if (!id &&\n        isElement(parentNode) &&\n        parentNode.localName === \"CascadingStyle\") {\n        id = parentNode.getAttribute(\"kml:id\") || parentNode.getAttribute(\"id\");\n    }\n    return normalizeId(id || \"\");\n}\nfunction buildStyleMap(node) {\n    const styleMap = {};\n    for (const style of $(node, \"Style\")) {\n        styleMap[getStyleId(style)] = extractStyle(style);\n    }\n    for (const map of $(node, \"StyleMap\")) {\n        const id = normalizeId(map.getAttribute(\"id\") || \"\");\n        val1(map, \"styleUrl\", (styleUrl) => {\n            styleUrl = normalizeId(styleUrl);\n            if (styleMap[styleUrl]) {\n                styleMap[id] = styleMap[styleUrl];\n            }\n        });\n    }\n    return styleMap;\n}\nconst FOLDER_PROPS = [\n    \"name\",\n    \"visibility\",\n    \"open\",\n    \"address\",\n    \"description\",\n    \"phoneNumber\",\n    \"visibility\",\n];\nfunction getFolder(node) {\n    const meta = {};\n    for (const child of Array.from(node.childNodes)) {\n        if (isElement(child) && FOLDER_PROPS.includes(child.tagName)) {\n            meta[child.tagName] = nodeVal(child);\n        }\n    }\n    return {\n        type: \"folder\",\n        meta,\n        children: [],\n    };\n}\n/**\n * Yield a nested tree with KML folder structure\n *\n * This generates a tree with the given structure:\n *\n * ```js\n * {\n *   \"type\": \"root\",\n *   \"children\": [\n *     {\n *       \"type\": \"folder\",\n *       \"meta\": {\n *         \"name\": \"Test\"\n *       },\n *       \"children\": [\n *          // ...features and folders\n *       ]\n *     }\n *     // ...features\n *   ]\n * }\n * ```\n */\nfunction kmlWithFolders(node) {\n    const styleMap = buildStyleMap(node);\n    const tree = { type: \"root\", children: [] };\n    function traverse(node, pointer) {\n        if (isElement(node)) {\n            switch (node.tagName) {\n                case \"Placemark\": {\n                    const placemark = getPlacemark(node, styleMap);\n                    if (placemark) {\n                        pointer.children.push(placemark);\n                    }\n                    break;\n                }\n                case \"Folder\": {\n                    const folder = getFolder(node);\n                    pointer.children.push(folder);\n                    pointer = folder;\n                    break;\n                }\n            }\n        }\n        if (node.childNodes) {\n            for (let i = 0; i < node.childNodes.length; i++) {\n                traverse(node.childNodes[i], pointer);\n            }\n        }\n    }\n    traverse(node, tree);\n    return tree;\n}\n/**\n * Convert KML to GeoJSON incrementally, returning\n * a [Generator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators)\n * that yields output feature by feature.\n */\nfunction* kmlGen(node) {\n    const styleMap = buildStyleMap(node);\n    for (const placemark of $(node, \"Placemark\")) {\n        const feature = getPlacemark(placemark, styleMap);\n        if (feature)\n            yield feature;\n    }\n}\n/**\n * Convert a KML document to GeoJSON. The first argument, `doc`, must be a KML\n * document as an XML DOM - not as a string. You can get this using jQuery's default\n * `.ajax` function or using a bare XMLHttpRequest with the `.response` property\n * holding an XML DOM.\n *\n * The output is a JavaScript object of GeoJSON data. You can convert it to a string\n * with [JSON.stringify](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify)\n * or use it directly in libraries.\n */\nfunction kml(node) {\n    return {\n        type: \"FeatureCollection\",\n        features: Array.from(kmlGen(node)),\n    };\n}\n\nexport { gpx, gpxGen, kml, kmlGen, kmlWithFolders, tcx, tcxGen };\n//# sourceMappingURL=togeojson.es.mjs.map\n"],"names":["exports","objectConverter","columns","Function","map","name","i","JSON","stringify","join","customConverter","f","object","row","inferColumns","rows","columnSet","Object","create","forEach","column","push","dsv","delimiter","reFormat","RegExp","delimiterCode","charCodeAt","parse","text","convert","parseRows","t","eol","EOL","EOF","N","length","I","n","token","c","j","slice","replace","k","a","format","formatValue","concat","formatRows","formatRow","test","csv","csvParse","csvParseRows","csvFormat","csvFormatRows","tsv","tsvParse","tsvParseRows","tsvFormat","tsvFormatRows","dsvFormat","defineProperty","value","factory","input","dim","dms","coordToDMS","whole","minutes","seconds","dir","lat","lon","abs","Math","floor","fractionMinutes","search","dims","m","toUpperCase","match","matched","indexOf","deg","parseFloat","min","sec","sign","val","remain","sexagesimalModule","result","sexagesimal$1","pair","one","trim","two","b","swapdim","formatPair","require$$0","sexagesimal","require$$1","latRegex","lonRegex","guessHeader","regexp","score","guessLatHeader","guessLonHeader","keyCount","o","keys","autoDelimiter","x","results","res","count","arity","sort","csv2geojson_1","isLon","isLat","auto","deleteColumns","csv2geojson","options","callback","latfield","lonfield","crs","features","featurecollection","type","properties","numericFields","split","parsed","d","key","includes","errors","geometry","undefined","lonf","latf","lonk","latk","isNaN","message","index","includeLatLon","coordinates","toLine","gj","line","reduce","aggregatedProperties","newFeature","toPolygon","poly","identity","feature","topology","id","bbox","transformPoint","transform","x0","y0","kx","scale","ky","dx","translate","dy","output","Array","arcs","arc","points","pop","array","reverse","point","p","ring","polygon","geometries","$","element","tagName","from","getElementsByTagName","normalizeId","nodeVal","node","normalize","textContent","get1","get","val1","$num","num1","getMulti","propertyNames","property","isElement","nodeType","getLineStyle","lineStyle","assign","color","stroke","opacity","width","getExtensions","values","child","childNodes","abbreviateName","nodeName","parseNumeric","num","coordPair$1","ll","getAttribute","time","extendedValues","extractProperties","extensions","getElementsByTagNameNS","parentNode","links","link","href","getPoints$1","pointname","pts","times","plural","fill","getRoute","_gpxType","getTrack","segments","track","extractedLines","segment","multi","coordinateProperties","props","entries","getPoint","gpxGen","route","waypoint","TRACKPOINT_ATTRIBUTES","LAP_ATTRIBUTES","getProperties","attributeNames","tag","alias","elem","elements","coordPair","heartRate","alt","getPoints","heartRates","extendedProperties","getLap","allExtendedProperties","fromEntries","nameElement","heart","tcxGen","lap","course","fixColor","v","prefix","colorProp","substring","parseInt","numericProperty","source","target","getColor","extractStyle","polyStyle","outline","extractPoly","extractLine","labelStyle","extractLabel","iconStyle","hotspot","left","top","xunits","yunits","icon","extractIcon","removeSpace","trimSpace","splitSpace","coord1","filter","coord","gxCoords","elems","ns","$ns","fixRing","first","last","equal","max","GEO_TYPES","getCoordinates","getGeometry","coordTimes","geoType","geomNode","coords","linearRing","gx","extractExtendedData","extendedData","data","simpleData","geometryListToGeometry","extractTimeSpan","timeSpan","timespan","begin","end","extractTimeStamp","timeStamp","timestamp","extractCascadedStyle","styleMap","styleUrl","getMaybeHTMLDescription","descriptionNode","description","getPlacemark","getStyleId","style","localName","buildStyleMap","FOLDER_PROPS","kmlGen","placemark","tree","children","traverse","pointer","folder","meta","getFolder","objects"],"mappings":"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"}