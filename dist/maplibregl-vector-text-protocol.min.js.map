{"version":3,"file":"maplibregl-vector-text-protocol.min.js","sources":["../node_modules/d3-dsv/build/d3-dsv.js","../node_modules/@mapbox/sexagesimal/index.js","../node_modules/csv2geojson/index.js","../node_modules/topojson-client/src/identity.js","../node_modules/topojson-client/src/feature.js","../node_modules/topojson-client/src/transform.js","../node_modules/topojson-client/src/reverse.js","../node_modules/@tmcw/togeojson/dist/togeojson.js"],"sourcesContent":["// https://d3js.org/d3-dsv/ Version 1.0.1. Copyright 2016 Mike Bostock.\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.d3 = global.d3 || {})));\n}(this, function (exports) { 'use strict';\n\n  function objectConverter(columns) {\n    return new Function(\"d\", \"return {\" + columns.map(function(name, i) {\n      return JSON.stringify(name) + \": d[\" + i + \"]\";\n    }).join(\",\") + \"}\");\n  }\n\n  function customConverter(columns, f) {\n    var object = objectConverter(columns);\n    return function(row, i) {\n      return f(object(row), i, columns);\n    };\n  }\n\n  // Compute unique columns in order of discovery.\n  function inferColumns(rows) {\n    var columnSet = Object.create(null),\n        columns = [];\n\n    rows.forEach(function(row) {\n      for (var column in row) {\n        if (!(column in columnSet)) {\n          columns.push(columnSet[column] = column);\n        }\n      }\n    });\n\n    return columns;\n  }\n\n  function dsv(delimiter) {\n    var reFormat = new RegExp(\"[\\\"\" + delimiter + \"\\n]\"),\n        delimiterCode = delimiter.charCodeAt(0);\n\n    function parse(text, f) {\n      var convert, columns, rows = parseRows(text, function(row, i) {\n        if (convert) return convert(row, i - 1);\n        columns = row, convert = f ? customConverter(row, f) : objectConverter(row);\n      });\n      rows.columns = columns;\n      return rows;\n    }\n\n    function parseRows(text, f) {\n      var EOL = {}, // sentinel value for end-of-line\n          EOF = {}, // sentinel value for end-of-file\n          rows = [], // output rows\n          N = text.length,\n          I = 0, // current character index\n          n = 0, // the current line number\n          t, // the current token\n          eol; // is the current token followed by EOL?\n\n      function token() {\n        if (I >= N) return EOF; // special case: end of file\n        if (eol) return eol = false, EOL; // special case: end of line\n\n        // special case: quotes\n        var j = I, c;\n        if (text.charCodeAt(j) === 34) {\n          var i = j;\n          while (i++ < N) {\n            if (text.charCodeAt(i) === 34) {\n              if (text.charCodeAt(i + 1) !== 34) break;\n              ++i;\n            }\n          }\n          I = i + 2;\n          c = text.charCodeAt(i + 1);\n          if (c === 13) {\n            eol = true;\n            if (text.charCodeAt(i + 2) === 10) ++I;\n          } else if (c === 10) {\n            eol = true;\n          }\n          return text.slice(j + 1, i).replace(/\"\"/g, \"\\\"\");\n        }\n\n        // common case: find next delimiter or newline\n        while (I < N) {\n          var k = 1;\n          c = text.charCodeAt(I++);\n          if (c === 10) eol = true; // \\n\n          else if (c === 13) { eol = true; if (text.charCodeAt(I) === 10) ++I, ++k; } // \\r|\\r\\n\n          else if (c !== delimiterCode) continue;\n          return text.slice(j, I - k);\n        }\n\n        // special case: last token before EOF\n        return text.slice(j);\n      }\n\n      while ((t = token()) !== EOF) {\n        var a = [];\n        while (t !== EOL && t !== EOF) {\n          a.push(t);\n          t = token();\n        }\n        if (f && (a = f(a, n++)) == null) continue;\n        rows.push(a);\n      }\n\n      return rows;\n    }\n\n    function format(rows, columns) {\n      if (columns == null) columns = inferColumns(rows);\n      return [columns.map(formatValue).join(delimiter)].concat(rows.map(function(row) {\n        return columns.map(function(column) {\n          return formatValue(row[column]);\n        }).join(delimiter);\n      })).join(\"\\n\");\n    }\n\n    function formatRows(rows) {\n      return rows.map(formatRow).join(\"\\n\");\n    }\n\n    function formatRow(row) {\n      return row.map(formatValue).join(delimiter);\n    }\n\n    function formatValue(text) {\n      return text == null ? \"\"\n          : reFormat.test(text += \"\") ? \"\\\"\" + text.replace(/\\\"/g, \"\\\"\\\"\") + \"\\\"\"\n          : text;\n    }\n\n    return {\n      parse: parse,\n      parseRows: parseRows,\n      format: format,\n      formatRows: formatRows\n    };\n  }\n\n  var csv = dsv(\",\");\n\n  var csvParse = csv.parse;\n  var csvParseRows = csv.parseRows;\n  var csvFormat = csv.format;\n  var csvFormatRows = csv.formatRows;\n\n  var tsv = dsv(\"\\t\");\n\n  var tsvParse = tsv.parse;\n  var tsvParseRows = tsv.parseRows;\n  var tsvFormat = tsv.format;\n  var tsvFormatRows = tsv.formatRows;\n\n  exports.dsvFormat = dsv;\n  exports.csvParse = csvParse;\n  exports.csvParseRows = csvParseRows;\n  exports.csvFormat = csvFormat;\n  exports.csvFormatRows = csvFormatRows;\n  exports.tsvParse = tsvParse;\n  exports.tsvParseRows = tsvParseRows;\n  exports.tsvFormat = tsvFormat;\n  exports.tsvFormatRows = tsvFormatRows;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));","module.exports = element;\nmodule.exports.pair = pair;\nmodule.exports.format = format;\nmodule.exports.formatPair = formatPair;\nmodule.exports.coordToDMS = coordToDMS;\n\n\nfunction element(input, dims) {\n  var result = search(input, dims);\n  return (result === null) ? null : result.val;\n}\n\n\nfunction formatPair(input) {\n  return format(input.lat, 'lat') + ' ' + format(input.lon, 'lon');\n}\n\n\n// Is 0 North or South?\nfunction format(input, dim) {\n  var dms = coordToDMS(input, dim);\n  return dms.whole + '° ' +\n    (dms.minutes ? dms.minutes + '\\' ' : '') +\n    (dms.seconds ? dms.seconds + '\" ' : '') + dms.dir;\n}\n\n\nfunction coordToDMS(input, dim) {\n  var dirs = { lat: ['N', 'S'], lon: ['E', 'W'] }[dim] || '';\n  var dir = dirs[input >= 0 ? 0 : 1];\n  var abs = Math.abs(input);\n  var whole = Math.floor(abs);\n  var fraction = abs - whole;\n  var fractionMinutes = fraction * 60;\n  var minutes = Math.floor(fractionMinutes);\n  var seconds = Math.floor((fractionMinutes - minutes) * 60);\n\n  return {\n    whole: whole,\n    minutes: minutes,\n    seconds: seconds,\n    dir: dir\n  };\n}\n\n\nfunction search(input, dims) {\n  if (!dims) dims = 'NSEW';\n  if (typeof input !== 'string') return null;\n\n  input = input.toUpperCase();\n  var regex = /^[\\s\\,]*([NSEW])?\\s*([\\-|\\—|\\―]?[0-9.]+)[°º˚]?\\s*(?:([0-9.]+)['’′‘]\\s*)?(?:([0-9.]+)(?:''|\"|”|″)\\s*)?([NSEW])?/;\n\n  var m = input.match(regex);\n  if (!m) return null;  // no match\n\n  var matched = m[0];\n\n  // extract dimension.. m[1] = leading, m[5] = trailing\n  var dim;\n  if (m[1] && m[5]) {                 // if matched both..\n    dim = m[1];                       // keep leading\n    matched = matched.slice(0, -1);   // remove trailing dimension from match\n  } else {\n    dim = m[1] || m[5];\n  }\n\n  // if unrecognized dimension\n  if (dim && dims.indexOf(dim) === -1) return null;\n\n  // extract DMS\n  var deg = m[2] ? parseFloat(m[2]) : 0;\n  var min = m[3] ? parseFloat(m[3]) / 60 : 0;\n  var sec = m[4] ? parseFloat(m[4]) / 3600 : 0;\n  var sign = (deg < 0) ? -1 : 1;\n  if (dim === 'S' || dim === 'W') sign *= -1;\n\n  return {\n    val: (Math.abs(deg) + min + sec) * sign,\n    dim: dim,\n    matched: matched,\n    remain: input.slice(matched.length)\n  };\n}\n\n\nfunction pair(input, dims) {\n  input = input.trim();\n  var one = search(input, dims);\n  if (!one) return null;\n\n  input = one.remain.trim();\n  var two = search(input, dims);\n  if (!two || two.remain) return null;\n\n  if (one.dim) {\n    return swapdim(one.val, two.val, one.dim);\n  } else {\n    return [one.val, two.val];\n  }\n}\n\n\nfunction swapdim(a, b, dim) {\n  if (dim === 'N' || dim === 'S') return [a, b];\n  if (dim === 'W' || dim === 'E') return [b, a];\n}\n","'use strict';\n\nvar dsv = require('d3-dsv'),\n    sexagesimal = require('@mapbox/sexagesimal');\n\nvar latRegex = /(Lat)(itude)?/gi,\n    lonRegex = /(L)(on|ng)(gitude)?/i;\n\nfunction guessHeader(row, regexp) {\n    var name, match, score;\n    for (var f in row) {\n        match = f.match(regexp);\n        if (match && (!name || match[0].length / f.length > score)) {\n            score = match[0].length / f.length;\n            name = f;\n        }\n    }\n    return name;\n}\n\nfunction guessLatHeader(row) { return guessHeader(row, latRegex); }\nfunction guessLonHeader(row) { return guessHeader(row, lonRegex); }\n\nfunction isLat(f) { return !!f.match(latRegex); }\nfunction isLon(f) { return !!f.match(lonRegex); }\n\nfunction keyCount(o) {\n    return (typeof o == 'object') ? Object.keys(o).length : 0;\n}\n\nfunction autoDelimiter(x) {\n    var delimiters = [',', ';', '\\t', '|'];\n    var results = [];\n\n    delimiters.forEach(function (delimiter) {\n        var res = dsv.dsvFormat(delimiter).parse(x);\n        if (res.length >= 1) {\n            var count = keyCount(res[0]);\n            for (var i = 0; i < res.length; i++) {\n                if (keyCount(res[i]) !== count) return;\n            }\n            results.push({\n                delimiter: delimiter,\n                arity: Object.keys(res[0]).length,\n            });\n        }\n    });\n\n    if (results.length) {\n        return results.sort(function (a, b) {\n            return b.arity - a.arity;\n        })[0].delimiter;\n    } else {\n        return null;\n    }\n}\n\n/**\n * Silly stopgap for dsv to d3-dsv upgrade\n *\n * @param {Array} x dsv output\n * @returns {Array} array without columns member\n */\nfunction deleteColumns(x) {\n    delete x.columns;\n    return x;\n}\n\nfunction auto(x) {\n    var delimiter = autoDelimiter(x);\n    if (!delimiter) return null;\n    return deleteColumns(dsv.dsvFormat(delimiter).parse(x));\n}\n\nfunction csv2geojson(x, options, callback) {\n\n    if (!callback) {\n        callback = options;\n        options = {};\n    }\n\n    options.delimiter = options.delimiter || ',';\n\n    var latfield = options.latfield || '',\n        lonfield = options.lonfield || '',\n        crs = options.crs || '';\n\n    var features = [],\n        featurecollection = {type: 'FeatureCollection', features: features};\n\n    if (crs !== '') {\n        featurecollection.crs = {type: 'name', properties: {name: crs}};\n    }\n\n    if (options.delimiter === 'auto' && typeof x == 'string') {\n        options.delimiter = autoDelimiter(x);\n        if (!options.delimiter) {\n            callback({\n                type: 'Error',\n                message: 'Could not autodetect delimiter'\n            });\n            return;\n        }\n    }\n\n    var numericFields = options.numericFields ? options.numericFields.split(',') : null;\n\n    var parsed = (typeof x == 'string') ?\n        dsv.dsvFormat(options.delimiter).parse(x, function (d) {\n            if (numericFields) {\n                for (var key in d) {\n                    if (numericFields.includes(key)) {\n                        d[key] = +d[key];\n                    }\n                }\n            }\n            return d;\n        }) : x;\n\n    if (!parsed.length) {\n        callback(null, featurecollection);\n        return;\n    }\n\n    var errors = [];\n    var i;\n\n\n    if (!latfield) latfield = guessLatHeader(parsed[0]);\n    if (!lonfield) lonfield = guessLonHeader(parsed[0]);\n    var noGeometry = (!latfield || !lonfield);\n\n    if (noGeometry) {\n        for (i = 0; i < parsed.length; i++) {\n            features.push({\n                type: 'Feature',\n                properties: parsed[i],\n                geometry: null\n            });\n        }\n        callback(errors.length ? errors : null, featurecollection);\n        return;\n    }\n\n    for (i = 0; i < parsed.length; i++) {\n        if (parsed[i][lonfield] !== undefined &&\n            parsed[i][latfield] !== undefined) {\n\n            var lonk = parsed[i][lonfield],\n                latk = parsed[i][latfield],\n                lonf, latf,\n                a;\n\n            a = sexagesimal(lonk, 'EW');\n            if (a) lonk = a;\n            a = sexagesimal(latk, 'NS');\n            if (a) latk = a;\n\n            lonf = parseFloat(lonk);\n            latf = parseFloat(latk);\n\n            if (isNaN(lonf) ||\n                isNaN(latf)) {\n                errors.push({\n                    message: 'A row contained an invalid value for latitude or longitude',\n                    row: parsed[i],\n                    index: i\n                });\n            } else {\n                if (!options.includeLatLon) {\n                    delete parsed[i][lonfield];\n                    delete parsed[i][latfield];\n                }\n\n                features.push({\n                    type: 'Feature',\n                    properties: parsed[i],\n                    geometry: {\n                        type: 'Point',\n                        coordinates: [\n                            parseFloat(lonf),\n                            parseFloat(latf)\n                        ]\n                    }\n                });\n            }\n        }\n    }\n\n    callback(errors.length ? errors : null, featurecollection);\n}\n\nfunction toLine(gj) {\n    var features = gj.features;\n    var line = {\n        type: 'Feature',\n        geometry: {\n            type: 'LineString',\n            coordinates: []\n        }\n    };\n    for (var i = 0; i < features.length; i++) {\n        line.geometry.coordinates.push(features[i].geometry.coordinates);\n    }\n    line.properties = features.reduce(function (aggregatedProperties, newFeature) {\n        for (var key in newFeature.properties) {\n            if (!aggregatedProperties[key]) {\n                aggregatedProperties[key] = [];\n            }\n            aggregatedProperties[key].push(newFeature.properties[key]);\n        }\n        return aggregatedProperties;\n    }, {});\n    return {\n        type: 'FeatureCollection',\n        features: [line]\n    };\n}\n\nfunction toPolygon(gj) {\n    var features = gj.features;\n    var poly = {\n        type: 'Feature',\n        geometry: {\n            type: 'Polygon',\n            coordinates: [[]]\n        }\n    };\n    for (var i = 0; i < features.length; i++) {\n        poly.geometry.coordinates[0].push(features[i].geometry.coordinates);\n    }\n    poly.properties = features.reduce(function (aggregatedProperties, newFeature) {\n        for (var key in newFeature.properties) {\n            if (!aggregatedProperties[key]) {\n                aggregatedProperties[key] = [];\n            }\n            aggregatedProperties[key].push(newFeature.properties[key]);\n        }\n        return aggregatedProperties;\n    }, {});\n    return {\n        type: 'FeatureCollection',\n        features: [poly]\n    };\n}\n\nmodule.exports = {\n    isLon: isLon,\n    isLat: isLat,\n    guessLatHeader: guessLatHeader,\n    guessLonHeader: guessLonHeader,\n    csv: dsv.csvParse,\n    tsv: dsv.tsvParse,\n    dsv: dsv,\n    auto: auto,\n    csv2geojson: csv2geojson,\n    toLine: toLine,\n    toPolygon: toPolygon\n};\n","export default function(x) {\n  return x;\n}\n","import reverse from \"./reverse.js\";\nimport transform from \"./transform.js\";\n\nexport default function(topology, o) {\n  if (typeof o === \"string\") o = topology.objects[o];\n  return o.type === \"GeometryCollection\"\n      ? {type: \"FeatureCollection\", features: o.geometries.map(function(o) { return feature(topology, o); })}\n      : feature(topology, o);\n}\n\nfunction feature(topology, o) {\n  var id = o.id,\n      bbox = o.bbox,\n      properties = o.properties == null ? {} : o.properties,\n      geometry = object(topology, o);\n  return id == null && bbox == null ? {type: \"Feature\", properties: properties, geometry: geometry}\n      : bbox == null ? {type: \"Feature\", id: id, properties: properties, geometry: geometry}\n      : {type: \"Feature\", id: id, bbox: bbox, properties: properties, geometry: geometry};\n}\n\nexport function object(topology, o) {\n  var transformPoint = transform(topology.transform),\n      arcs = topology.arcs;\n\n  function arc(i, points) {\n    if (points.length) points.pop();\n    for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {\n      points.push(transformPoint(a[k], k));\n    }\n    if (i < 0) reverse(points, n);\n  }\n\n  function point(p) {\n    return transformPoint(p);\n  }\n\n  function line(arcs) {\n    var points = [];\n    for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);\n    if (points.length < 2) points.push(points[0]); // This should never happen per the specification.\n    return points;\n  }\n\n  function ring(arcs) {\n    var points = line(arcs);\n    while (points.length < 4) points.push(points[0]); // This may happen if an arc has only two points.\n    return points;\n  }\n\n  function polygon(arcs) {\n    return arcs.map(ring);\n  }\n\n  function geometry(o) {\n    var type = o.type, coordinates;\n    switch (type) {\n      case \"GeometryCollection\": return {type: type, geometries: o.geometries.map(geometry)};\n      case \"Point\": coordinates = point(o.coordinates); break;\n      case \"MultiPoint\": coordinates = o.coordinates.map(point); break;\n      case \"LineString\": coordinates = line(o.arcs); break;\n      case \"MultiLineString\": coordinates = o.arcs.map(line); break;\n      case \"Polygon\": coordinates = polygon(o.arcs); break;\n      case \"MultiPolygon\": coordinates = o.arcs.map(polygon); break;\n      default: return null;\n    }\n    return {type: type, coordinates: coordinates};\n  }\n\n  return geometry(o);\n}\n","import identity from \"./identity.js\";\n\nexport default function(transform) {\n  if (transform == null) return identity;\n  var x0,\n      y0,\n      kx = transform.scale[0],\n      ky = transform.scale[1],\n      dx = transform.translate[0],\n      dy = transform.translate[1];\n  return function(input, i) {\n    if (!i) x0 = y0 = 0;\n    var j = 2, n = input.length, output = new Array(n);\n    output[0] = (x0 += input[0]) * kx + dx;\n    output[1] = (y0 += input[1]) * ky + dy;\n    while (j < n) output[j] = input[j], ++j;\n    return output;\n  };\n}\n","export default function(array, n) {\n  var t, j = array.length, i = j - n;\n  while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;\n}\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n// cast array x into numbers\n// get the content of a text node, if any\nfunction nodeVal(x) {\n  if (x && x.normalize) {\n    x.normalize();\n  }\n  return (x && x.textContent) || \"\";\n}\n\n// one Y child of X, if any, otherwise null\nfunction get1(x, y) {\n  const n = x.getElementsByTagName(y);\n  return n.length ? n[0] : null;\n}\n\nfunction getLineStyle(extensions) {\n  const style = {};\n  if (extensions) {\n    const lineStyle = get1(extensions, \"line\");\n    if (lineStyle) {\n      const color = nodeVal(get1(lineStyle, \"color\")),\n        opacity = parseFloat(nodeVal(get1(lineStyle, \"opacity\"))),\n        width = parseFloat(nodeVal(get1(lineStyle, \"width\")));\n      if (color) style.stroke = color;\n      if (!isNaN(opacity)) style[\"stroke-opacity\"] = opacity;\n      // GPX width is in mm, convert to px with 96 px per inch\n      if (!isNaN(width)) style[\"stroke-width\"] = (width * 96) / 25.4;\n    }\n  }\n  return style;\n}\n\n// get the contents of multiple text nodes, if present\nfunction getMulti(x, ys) {\n  const o = {};\n  let n;\n  let k;\n  for (k = 0; k < ys.length; k++) {\n    n = get1(x, ys[k]);\n    if (n) o[ys[k]] = nodeVal(n);\n  }\n  return o;\n}\nfunction getProperties$1(node) {\n  const prop = getMulti(node, [\n    \"name\",\n    \"cmt\",\n    \"desc\",\n    \"type\",\n    \"time\",\n    \"keywords\",\n  ]);\n  // Parse additional data from our Garmin extension(s)\n  const extensions = node.getElementsByTagNameNS(\n    \"http://www.garmin.com/xmlschemas/GpxExtensions/v3\",\n    \"*\"\n  );\n  for (let i = 0; i < extensions.length; i++) {\n    const extension = extensions[i];\n    // Ignore nested extensions, like those on routepoints or trackpoints\n    if (extension.parentNode.parentNode === node) {\n      prop[extension.tagName.replace(\":\", \"_\")] = nodeVal(extension);\n    }\n  }\n  const links = node.getElementsByTagName(\"link\");\n  if (links.length) prop.links = [];\n  for (let i = 0; i < links.length; i++) {\n    prop.links.push(\n      Object.assign(\n        { href: links[i].getAttribute(\"href\") },\n        getMulti(links[i], [\"text\", \"type\"])\n      )\n    );\n  }\n  return prop;\n}\n\nfunction coordPair$1(x) {\n  const ll = [\n    parseFloat(x.getAttribute(\"lon\")),\n    parseFloat(x.getAttribute(\"lat\")),\n  ];\n  const ele = get1(x, \"ele\");\n  // handle namespaced attribute in browser\n  const heart = get1(x, \"gpxtpx:hr\") || get1(x, \"hr\");\n  const time = get1(x, \"time\");\n  let e;\n  if (ele) {\n    e = parseFloat(nodeVal(ele));\n    if (!isNaN(e)) {\n      ll.push(e);\n    }\n  }\n  const result = {\n    coordinates: ll,\n    time: time ? nodeVal(time) : null,\n    extendedValues: [],\n  };\n\n  if (heart) {\n    result.extendedValues.push([\"heart\", parseFloat(nodeVal(heart))]);\n  }\n\n  const extensions = get1(x, \"extensions\");\n  if (extensions !== null) {\n    for (const name of [\"speed\", \"course\", \"hAcc\", \"vAcc\"]) {\n      const v = parseFloat(nodeVal(get1(extensions, name)));\n      if (!isNaN(v)) {\n        result.extendedValues.push([name, v]);\n      }\n    }\n  }\n  return result;\n}\nfunction getRoute(node) {\n  const line = getPoints$1(node, \"rtept\");\n  if (!line) return;\n  return {\n    type: \"Feature\",\n    properties: Object.assign(\n      getProperties$1(node),\n      getLineStyle(get1(node, \"extensions\")),\n      { _gpxType: \"rte\" }\n    ),\n    geometry: {\n      type: \"LineString\",\n      coordinates: line.line,\n    },\n  };\n}\n\nfunction getPoints$1(node, pointname) {\n  const pts = node.getElementsByTagName(pointname);\n  if (pts.length < 2) return; // Invalid line in GeoJSON\n\n  const line = [];\n  const times = [];\n  const extendedValues = {};\n  for (let i = 0; i < pts.length; i++) {\n    const c = coordPair$1(pts[i]);\n    line.push(c.coordinates);\n    if (c.time) times.push(c.time);\n    for (let j = 0; j < c.extendedValues.length; j++) {\n      const [name, val] = c.extendedValues[j];\n      const plural = name === \"heart\" ? name : name + \"s\";\n      if (!extendedValues[plural]) {\n        extendedValues[plural] = Array(pts.length).fill(null);\n      }\n      extendedValues[plural][i] = val;\n    }\n  }\n  return {\n    line: line,\n    times: times,\n    extendedValues: extendedValues,\n  };\n}\n\nfunction getTrack(node) {\n  const segments = node.getElementsByTagName(\"trkseg\");\n  const track = [];\n  const times = [];\n  const extractedLines = [];\n\n  for (let i = 0; i < segments.length; i++) {\n    const line = getPoints$1(segments[i], \"trkpt\");\n    if (line) {\n      extractedLines.push(line);\n      if (line.times && line.times.length) times.push(line.times);\n    }\n  }\n\n  if (extractedLines.length === 0) return;\n\n  const multi = extractedLines.length > 1;\n\n  const properties = Object.assign(\n    getProperties$1(node),\n    getLineStyle(get1(node, \"extensions\")),\n    { _gpxType: \"trk\" },\n    times.length\n      ? {\n          coordinateProperties: {\n            times: multi ? times : times[0],\n          }\n        }\n      : {}\n  );\n\n  for (let i = 0; i < extractedLines.length; i++) {\n    const line = extractedLines[i];\n    track.push(line.line);\n    for (const [name, val] of Object.entries(line.extendedValues)) {\n      let props = properties;\n      if (name === \"heart\") {\n        if (!properties.coordinateProperties) {\n          properties.coordinateProperties = {};\n        }\n        props = properties.coordinateProperties;\n      }\n      if (multi) {\n        if (!props[name])\n          props[name] = extractedLines.map((line) =>\n            new Array(line.line.length).fill(null)\n          );\n        props[name][i] = val;\n      } else {\n        props[name] = val;\n      }\n    }\n  }\n\n  return {\n    type: \"Feature\",\n    properties: properties,\n    geometry: multi\n      ? {\n        type: \"MultiLineString\",\n        coordinates: track,\n      }\n      : {\n        type: \"LineString\",\n        coordinates: track[0],\n      },\n  };\n}\n\nfunction getPoint(node) {\n  return {\n    type: \"Feature\",\n    properties: Object.assign(getProperties$1(node), getMulti(node, [\"sym\"])),\n    geometry: {\n      type: \"Point\",\n      coordinates: coordPair$1(node).coordinates,\n    },\n  };\n}\n\nfunction* gpxGen(doc) {\n  const tracks = doc.getElementsByTagName(\"trk\");\n  const routes = doc.getElementsByTagName(\"rte\");\n  const waypoints = doc.getElementsByTagName(\"wpt\");\n\n  for (let i = 0; i < tracks.length; i++) {\n    const feature = getTrack(tracks[i]);\n    if (feature) yield feature;\n  }\n  for (let i = 0; i < routes.length; i++) {\n    const feature = getRoute(routes[i]);\n    if (feature) yield feature;\n  }\n  for (let i = 0; i < waypoints.length; i++) {\n    yield getPoint(waypoints[i]);\n  }\n}\n\nfunction gpx(doc) {\n  return {\n    type: \"FeatureCollection\",\n    features: Array.from(gpxGen(doc)),\n  };\n}\n\nconst EXTENSIONS_NS = \"http://www.garmin.com/xmlschemas/ActivityExtension/v2\";\n\nconst TRACKPOINT_ATTRIBUTES = [\n  [\"heartRate\", \"heartRates\"],\n  [\"Cadence\", \"cadences\"],\n  // Extended Trackpoint attributes\n  [\"Speed\", \"speeds\"],\n  [\"Watts\", \"watts\"],\n];\n\nconst LAP_ATTRIBUTES = [\n  [\"TotalTimeSeconds\", \"totalTimeSeconds\"],\n  [\"DistanceMeters\", \"distanceMeters\"],\n  [\"MaximumSpeed\", \"maxSpeed\"],\n  [\"AverageHeartRateBpm\", \"avgHeartRate\"],\n  [\"MaximumHeartRateBpm\", \"maxHeartRate\"],\n\n  // Extended Lap attributes\n  [\"AvgSpeed\", \"avgSpeed\"],\n  [\"AvgWatts\", \"avgWatts\"],\n  [\"MaxWatts\", \"maxWatts\"],\n];\n\nfunction fromEntries(arr) {\n  const obj = {};\n  for (const [key, value] of arr) {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nfunction getProperties(node, attributeNames) {\n  const properties = [];\n\n  for (const [tag, alias] of attributeNames) {\n    let elem = get1(node, tag);\n    if (!elem) {\n      const elements = node.getElementsByTagNameNS(EXTENSIONS_NS, tag);\n      if (elements.length) {\n        elem = elements[0];\n      }\n    }\n    const val = parseFloat(nodeVal(elem));\n    if (!isNaN(val)) {\n      properties.push([alias, val]);\n    }\n  }\n\n  return properties;\n}\n\nfunction coordPair(x) {\n  const lon = nodeVal(get1(x, \"LongitudeDegrees\"));\n  const lat = nodeVal(get1(x, \"LatitudeDegrees\"));\n  if (!lon.length || !lat.length) {\n    return null;\n  }\n  const ll = [parseFloat(lon), parseFloat(lat)];\n  const alt = get1(x, \"AltitudeMeters\");\n  const heartRate = get1(x, \"HeartRateBpm\");\n  const time = get1(x, \"Time\");\n  let a;\n  if (alt) {\n    a = parseFloat(nodeVal(alt));\n    if (!isNaN(a)) {\n      ll.push(a);\n    }\n  }\n  return {\n    coordinates: ll,\n    time: time ? nodeVal(time) : null,\n    heartRate: heartRate ? parseFloat(nodeVal(heartRate)) : null,\n    extensions: getProperties(x, TRACKPOINT_ATTRIBUTES),\n  };\n}\n\nfunction getPoints(node, pointname) {\n  const pts = node.getElementsByTagName(pointname);\n  const line = [];\n  const times = [];\n  const heartRates = [];\n  if (pts.length < 2) return null; // Invalid line in GeoJSON\n  const result = { extendedProperties: {} };\n  for (let i = 0; i < pts.length; i++) {\n    const c = coordPair(pts[i]);\n    if (c === null) continue;\n    line.push(c.coordinates);\n    if (c.time) times.push(c.time);\n    if (c.heartRate) heartRates.push(c.heartRate);\n    for (const [alias, value] of c.extensions) {\n      if (!result.extendedProperties[alias]) {\n        result.extendedProperties[alias] = Array(pts.length).fill(null);\n      }\n      result.extendedProperties[alias][i] = value;\n    }\n  }\n  return Object.assign(result, {\n    line: line,\n    times: times,\n    heartRates: heartRates,\n  });\n}\n\nfunction getLap(node) {\n  const segments = node.getElementsByTagName(\"Track\");\n  const track = [];\n  const times = [];\n  const heartRates = [];\n  const allExtendedProperties = [];\n  let line;\n  const properties = fromEntries(getProperties(node, LAP_ATTRIBUTES));\n\n  const nameElement = get1(node, 'Name');\n  if (nameElement) {\n    properties.name = nodeVal(nameElement);\n  }\n\n  for (let i = 0; i < segments.length; i++) {\n    line = getPoints(segments[i], \"Trackpoint\");\n    if (line) {\n      track.push(line.line);\n      if (line.times.length) times.push(line.times);\n      if (line.heartRates.length) heartRates.push(line.heartRates);\n      allExtendedProperties.push(line.extendedProperties);\n    }\n  }\n  for (let i = 0; i < allExtendedProperties.length; i++) {\n    const extendedProperties = allExtendedProperties[i];\n    for (const property in extendedProperties) {\n      if (segments.length === 1) {\n        properties[property] = line.extendedProperties[property];\n      } else {\n        if (!properties[property]) {\n          properties[property] = track.map((track) =>\n            Array(track.length).fill(null)\n          );\n        }\n        properties[property][i] = extendedProperties[property];\n      }\n    }\n  }\n  if (track.length === 0) return;\n\n  if (times.length || heartRates.length) {\n    properties.coordinateProperties = Object.assign(\n      times.length\n        ? {\n            times: track.length === 1 ? times[0] : times,\n          }\n        : {},\n      heartRates.length\n        ? {\n            heart: track.length === 1 ? heartRates[0] : heartRates,\n          }\n        : {}\n    );\n  }\n\n  return {\n    type: \"Feature\",\n    properties: properties,\n    geometry: {\n      type: track.length === 1 ? \"LineString\" : \"MultiLineString\",\n      coordinates: track.length === 1 ? track[0] : track,\n    },\n  };\n}\n\nfunction* tcxGen(doc) {\n  const laps = doc.getElementsByTagName(\"Lap\");\n\n  for (let i = 0; i < laps.length; i++) {\n    const feature = getLap(laps[i]);\n    if (feature) yield feature;\n  }\n\n  const courses = doc.getElementsByTagName(\"Courses\");\n\n  for (let i = 0; i < courses.length; i++) {\n    const feature = getLap(courses[i]);\n    if (feature) yield feature;\n  }\n}\n\nfunction tcx(doc) {\n  return {\n    type: \"FeatureCollection\",\n    features: Array.from(tcxGen(doc)),\n  };\n}\n\nconst removeSpace = /\\s*/g;\nconst trimSpace = /^\\s*|\\s*$/g;\nconst splitSpace = /\\s+/;\n\n// generate a short, numeric hash of a string\nfunction okhash(x) {\n  if (!x || !x.length) return 0;\n  let h = 0;\n  for (let i = 0; i < x.length; i++) {\n    h = ((h << 5) - h + x.charCodeAt(i)) | 0;\n  }\n  return h;\n}\n\n// get one coordinate from a coordinate array, if any\nfunction coord1(v) {\n  return v.replace(removeSpace, \"\").split(\",\").map(parseFloat);\n}\n\n// get all coordinates from a coordinate array as [[],[]]\nfunction coord(v) {\n  return v.replace(trimSpace, \"\").split(splitSpace).map(coord1);\n}\n\nfunction xml2str(node) {\n  if (node.xml !== undefined) return node.xml;\n  if (node.tagName) {\n    let output = node.tagName;\n    for (let i = 0; i < node.attributes.length; i++) {\n      output += node.attributes[i].name + node.attributes[i].value;\n    }\n    for (let i = 0; i < node.childNodes.length; i++) {\n      output += xml2str(node.childNodes[i]);\n    }\n    return output;\n  }\n  if (node.nodeName === \"#text\") {\n    return (node.nodeValue || node.value || \"\").trim();\n  }\n  if (node.nodeName === \"#cdata-section\") {\n    return node.nodeValue;\n  }\n  return \"\";\n}\n\nconst geotypes = [\"Polygon\", \"LineString\", \"Point\", \"Track\", \"gx:Track\"];\n\nfunction kmlColor(properties, elem, prefix) {\n  let v = nodeVal(get1(elem, \"color\")) || \"\";\n  const colorProp =\n    prefix == \"stroke\" || prefix === \"fill\" ? prefix : prefix + \"-color\";\n  if (v.substr(0, 1) === \"#\") {\n    v = v.substr(1);\n  }\n  if (v.length === 6 || v.length === 3) {\n    properties[colorProp] = v;\n  } else if (v.length === 8) {\n    properties[prefix + \"-opacity\"] = parseInt(v.substr(0, 2), 16) / 255;\n    properties[colorProp] =\n      \"#\" + v.substr(6, 2) + v.substr(4, 2) + v.substr(2, 2);\n  }\n}\n\nfunction numericProperty(properties, elem, source, target) {\n  const val = parseFloat(nodeVal(get1(elem, source)));\n  if (!isNaN(val)) properties[target] = val;\n}\n\nfunction gxCoords(root) {\n  let elems = root.getElementsByTagName(\"coord\");\n  const coords = [];\n  const times = [];\n  if (elems.length === 0) elems = root.getElementsByTagName(\"gx:coord\");\n  for (let i = 0; i < elems.length; i++) {\n    coords.push(nodeVal(elems[i]).split(\" \").map(parseFloat));\n  }\n  const timeElems = root.getElementsByTagName(\"when\");\n  for (let j = 0; j < timeElems.length; j++) times.push(nodeVal(timeElems[j]));\n  return {\n    coords: coords,\n    times: times,\n  };\n}\n\nfunction getGeometry(root) {\n  let geomNode;\n  let geomNodes;\n  let i;\n  let j;\n  let k;\n  const geoms = [];\n  const coordTimes = [];\n  if (get1(root, \"MultiGeometry\")) {\n    return getGeometry(get1(root, \"MultiGeometry\"));\n  }\n  if (get1(root, \"MultiTrack\")) {\n    return getGeometry(get1(root, \"MultiTrack\"));\n  }\n  if (get1(root, \"gx:MultiTrack\")) {\n    return getGeometry(get1(root, \"gx:MultiTrack\"));\n  }\n  for (i = 0; i < geotypes.length; i++) {\n    geomNodes = root.getElementsByTagName(geotypes[i]);\n    if (geomNodes) {\n      for (j = 0; j < geomNodes.length; j++) {\n        geomNode = geomNodes[j];\n        if (geotypes[i] === \"Point\") {\n          geoms.push({\n            type: \"Point\",\n            coordinates: coord1(nodeVal(get1(geomNode, \"coordinates\"))),\n          });\n        } else if (geotypes[i] === \"LineString\") {\n          geoms.push({\n            type: \"LineString\",\n            coordinates: coord(nodeVal(get1(geomNode, \"coordinates\"))),\n          });\n        } else if (geotypes[i] === \"Polygon\") {\n          const rings = geomNode.getElementsByTagName(\"LinearRing\"),\n            coords = [];\n          for (k = 0; k < rings.length; k++) {\n            coords.push(coord(nodeVal(get1(rings[k], \"coordinates\"))));\n          }\n          geoms.push({\n            type: \"Polygon\",\n            coordinates: coords,\n          });\n        } else if (geotypes[i] === \"Track\" || geotypes[i] === \"gx:Track\") {\n          const track = gxCoords(geomNode);\n          geoms.push({\n            type: \"LineString\",\n            coordinates: track.coords,\n          });\n          if (track.times.length) coordTimes.push(track.times);\n        }\n      }\n    }\n  }\n  return {\n    geoms: geoms,\n    coordTimes: coordTimes,\n  };\n}\n\nfunction getPlacemark(root, styleIndex, styleMapIndex, styleByHash) {\n  const geomsAndTimes = getGeometry(root);\n  let i;\n  const properties = {};\n  const name = nodeVal(get1(root, \"name\"));\n  const address = nodeVal(get1(root, \"address\"));\n  let styleUrl = nodeVal(get1(root, \"styleUrl\"));\n  const description = nodeVal(get1(root, \"description\"));\n  const timeSpan = get1(root, \"TimeSpan\");\n  const timeStamp = get1(root, \"TimeStamp\");\n  const extendedData = get1(root, \"ExtendedData\");\n  let iconStyle = get1(root, \"IconStyle\");\n  let labelStyle = get1(root, \"LabelStyle\");\n  let lineStyle = get1(root, \"LineStyle\");\n  let polyStyle = get1(root, \"PolyStyle\");\n  const visibility = get1(root, \"visibility\");\n\n  if (name) properties.name = name;\n  if (address) properties.address = address;\n  if (styleUrl) {\n    if (styleUrl[0] !== \"#\") {\n      styleUrl = \"#\" + styleUrl;\n    }\n\n    properties.styleUrl = styleUrl;\n    if (styleIndex[styleUrl]) {\n      properties.styleHash = styleIndex[styleUrl];\n    }\n    if (styleMapIndex[styleUrl]) {\n      properties.styleMapHash = styleMapIndex[styleUrl];\n      properties.styleHash = styleIndex[styleMapIndex[styleUrl].normal];\n    }\n    // Try to populate the lineStyle or polyStyle since we got the style hash\n    const style = styleByHash[properties.styleHash];\n    if (style) {\n      if (!iconStyle) iconStyle = get1(style, \"IconStyle\");\n      if (!labelStyle) labelStyle = get1(style, \"LabelStyle\");\n      if (!lineStyle) lineStyle = get1(style, \"LineStyle\");\n      if (!polyStyle) polyStyle = get1(style, \"PolyStyle\");\n    }\n  }\n  if (description) properties.description = description;\n  if (timeSpan) {\n    const begin = nodeVal(get1(timeSpan, \"begin\"));\n    const end = nodeVal(get1(timeSpan, \"end\"));\n    properties.timespan = { begin: begin, end: end };\n  }\n  if (timeStamp) {\n    properties.timestamp = nodeVal(get1(timeStamp, \"when\"));\n  }\n  if (iconStyle) {\n    kmlColor(properties, iconStyle, \"icon\");\n    numericProperty(properties, iconStyle, \"scale\", \"icon-scale\");\n    numericProperty(properties, iconStyle, \"heading\", \"icon-heading\");\n\n    const hotspot = get1(iconStyle, \"hotSpot\");\n    if (hotspot) {\n      const left = parseFloat(hotspot.getAttribute(\"x\"));\n      const top = parseFloat(hotspot.getAttribute(\"y\"));\n      if (!isNaN(left) && !isNaN(top)) properties[\"icon-offset\"] = [left, top];\n    }\n    const icon = get1(iconStyle, \"Icon\");\n    if (icon) {\n      const href = nodeVal(get1(icon, \"href\"));\n      if (href) properties.icon = href;\n    }\n  }\n  if (labelStyle) {\n    kmlColor(properties, labelStyle, \"label\");\n    numericProperty(properties, labelStyle, \"scale\", \"label-scale\");\n  }\n  if (lineStyle) {\n    kmlColor(properties, lineStyle, \"stroke\");\n    numericProperty(properties, lineStyle, \"width\", \"stroke-width\");\n  }\n  if (polyStyle) {\n    kmlColor(properties, polyStyle, \"fill\");\n    const fill = nodeVal(get1(polyStyle, \"fill\"));\n    const outline = nodeVal(get1(polyStyle, \"outline\"));\n    if (fill)\n      properties[\"fill-opacity\"] =\n        fill === \"1\" ? properties[\"fill-opacity\"] || 1 : 0;\n    if (outline)\n      properties[\"stroke-opacity\"] =\n        outline === \"1\" ? properties[\"stroke-opacity\"] || 1 : 0;\n  }\n  if (extendedData) {\n    const datas = extendedData.getElementsByTagName(\"Data\"),\n      simpleDatas = extendedData.getElementsByTagName(\"SimpleData\");\n\n    for (i = 0; i < datas.length; i++) {\n      properties[datas[i].getAttribute(\"name\")] = nodeVal(\n        get1(datas[i], \"value\")\n      );\n    }\n    for (i = 0; i < simpleDatas.length; i++) {\n      properties[simpleDatas[i].getAttribute(\"name\")] = nodeVal(simpleDatas[i]);\n    }\n  }\n  if (visibility) {\n    properties.visibility = nodeVal(visibility);\n  }\n  if (geomsAndTimes.coordTimes.length) {\n    properties.coordinateProperties = {\n      times: geomsAndTimes.coordTimes.length === 1\n        ? geomsAndTimes.coordTimes[0]\n        : geomsAndTimes.coordTimes\n    };\n  }\n  const feature = {\n    type: \"Feature\",\n    geometry:\n      geomsAndTimes.geoms.length === 0\n        ? null\n        : geomsAndTimes.geoms.length === 1\n        ? geomsAndTimes.geoms[0]\n        : {\n            type: \"GeometryCollection\",\n            geometries: geomsAndTimes.geoms,\n          },\n    properties: properties,\n  };\n  if (root.getAttribute(\"id\")) feature.id = root.getAttribute(\"id\");\n  return feature;\n}\n\nfunction* kmlGen(doc) {\n  // styleindex keeps track of hashed styles in order to match feature\n  const styleIndex = {};\n  const styleByHash = {};\n  // stylemapindex keeps track of style maps to expose in properties\n  const styleMapIndex = {};\n  // atomic geospatial types supported by KML - MultiGeometry is\n  // handled separately\n  // all root placemarks in the file\n  const placemarks = doc.getElementsByTagName(\"Placemark\");\n  const styles = doc.getElementsByTagName(\"Style\");\n  const styleMaps = doc.getElementsByTagName(\"StyleMap\");\n\n  for (let k = 0; k < styles.length; k++) {\n    const hash = okhash(xml2str(styles[k])).toString(16);\n    styleIndex[\"#\" + styles[k].getAttribute(\"id\")] = hash;\n    styleByHash[hash] = styles[k];\n  }\n  for (let l = 0; l < styleMaps.length; l++) {\n    styleIndex[\"#\" + styleMaps[l].getAttribute(\"id\")] = okhash(\n      xml2str(styleMaps[l])\n    ).toString(16);\n    const pairs = styleMaps[l].getElementsByTagName(\"Pair\");\n    const pairsMap = {};\n    for (let m = 0; m < pairs.length; m++) {\n      pairsMap[nodeVal(get1(pairs[m], \"key\"))] = nodeVal(\n        get1(pairs[m], \"styleUrl\")\n      );\n    }\n    styleMapIndex[\"#\" + styleMaps[l].getAttribute(\"id\")] = pairsMap;\n  }\n  for (let j = 0; j < placemarks.length; j++) {\n    const feature = getPlacemark(\n      placemarks[j],\n      styleIndex,\n      styleMapIndex,\n      styleByHash\n    );\n    if (feature) yield feature;\n  }\n}\n\nfunction kml(doc) {\n  return {\n    type: \"FeatureCollection\",\n    features: Array.from(kmlGen(doc)),\n  };\n}\n\nexports.gpx = gpx;\nexports.gpxGen = gpxGen;\nexports.kml = kml;\nexports.kmlGen = kmlGen;\nexports.tcx = tcx;\nexports.tcxGen = tcxGen;\n//# sourceMappingURL=togeojson.js.map\n"],"names":["exports","objectConverter","columns","Function","map","name","i","JSON","stringify","join","customConverter","f","object","row","inferColumns","rows","columnSet","Object","create","forEach","column","push","dsv","delimiter","reFormat","RegExp","delimiterCode","charCodeAt","parse","text","convert","parseRows","t","eol","EOL","EOF","N","length","I","n","token","c","j","slice","replace","k","a","format","formatValue","concat","formatRows","formatRow","test","csv","csvParse","csvParseRows","csvFormat","csvFormatRows","tsv","tsvParse","tsvParseRows","tsvFormat","tsvFormatRows","dsvFormat","defineProperty","value","factory","input","dim","dms","coordToDMS","whole","minutes","seconds","dir","lat","lon","abs","Math","floor","fractionMinutes","search","dims","m","toUpperCase","match","matched","indexOf","deg","parseFloat","min","sec","sign","val","remain","result","one","trim","two","b","swapdim","require$$0","sexagesimal","require$$1","latRegex","lonRegex","guessHeader","regexp","score","guessLatHeader","guessLonHeader","keyCount","o","keys","autoDelimiter","x","results","res","count","arity","sort","csv2geojson_1","isLon","isLat","auto","deleteColumns","csv2geojson","options","callback","latfield","lonfield","crs","features","featurecollection","type","properties","numericFields","split","parsed","d","key","includes","errors","geometry","undefined","lonf","latf","lonk","latk","isNaN","message","index","includeLatLon","coordinates","toLine","gj","line","reduce","aggregatedProperties","newFeature","toPolygon","poly","feature","topology","id","bbox","transformPoint","transform","identity","x0","y0","kx","scale","ky","dx","translate","dy","output","Array","arcs","arc","points","pop","array","reverse","point","p","ring","polygon","geometries","nodeVal","normalize","textContent","get1","y","getElementsByTagName","getLineStyle","extensions","style","lineStyle","color","opacity","width","stroke","getMulti","ys","getProperties$1","node","prop","getElementsByTagNameNS","extension","parentNode","tagName","links","assign","href","getAttribute","coordPair$1","ll","ele","heart","time","e","extendedValues","v","getRoute","getPoints$1","_gpxType","pointname","pts","times","plural","fill","getTrack","segments","track","extractedLines","multi","coordinateProperties","entries","props","gpxGen","doc","tracks","routes","waypoints","togeojson","TRACKPOINT_ATTRIBUTES","LAP_ATTRIBUTES","getProperties","attributeNames","tag","alias","elem","elements","coordPair","alt","heartRate","getPoints","heartRates","extendedProperties","getLap","allExtendedProperties","arr","obj","fromEntries","nameElement","property","tcxGen","laps","courses","removeSpace","trimSpace","splitSpace","okhash","h","coord1","coord","xml2str","xml","attributes","childNodes","nodeName","nodeValue","geotypes","kmlColor","prefix","colorProp","substr","parseInt","numericProperty","source","target","gxCoords","root","elems","coords","timeElems","getGeometry","geomNode","geomNodes","geoms","coordTimes","rings","getPlacemark","styleIndex","styleMapIndex","styleByHash","geomsAndTimes","address","styleUrl","description","timeSpan","timeStamp","extendedData","iconStyle","labelStyle","polyStyle","visibility","styleHash","styleMapHash","normal","begin","end","timespan","timestamp","hotspot","left","top","icon","outline","datas","simpleDatas","kmlGen","placemarks","styles","styleMaps","hash","toString","l","pairs","pairsMap","from","objects"],"mappings":"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"}